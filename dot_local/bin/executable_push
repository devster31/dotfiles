#!/usr/bin/env bash
# Original version from: https://github.com/aaronfagan/pushover-cli

# ARG_OPTIONAL_SINGLE([token],[t],[your application's API token])
# ARG_USE_ENV([PUSHOVER_TOKEN],[],[used as fallback])

# ARG_OPTIONAL_SINGLE([user],[u],[the user/group key (not e-mail address) of your user (or you), viewable when logged into our dashboard (often referred to as USER_KEY in our documentation and code examples)])
# ARG_USE_ENV([PUSHOVER_USER],[],[used as fallback])

# ARG_OPTIONAL_SINGLE([message],[m],[your message])

# ARG_OPTIONAL_SINGLE([attachment],[],[an image attachment to send with the message; see attachments for more information on how to upload files])
# ARG_OPTIONAL_SINGLE([device],[],[your user's device name to send the message directly to that device, rather than all of the user's devices (multiple devices may be separated by a comma])
# ARG_OPTIONAL_SINGLE([title],[],[your message's title, otherwise your app's name is used])
# ARG_OPTIONAL_SINGLE([url],[],[a supplementary URL to show with your message])
# ARG_OPTIONAL_SINGLE([url_title],[],[a title for your supplementary URL, otherwise just the URL is shown])
# ARG_OPTIONAL_SINGLE([priority],[],[send as -2 to generate no notification/alert, -1 to always send as a quiet notification, 1 to display as high-priority and bypass the user's quiet hours, or 2 to also require confirmation from the user])
# ARG_OPTIONAL_SINGLE([sound],[],[the name of one of the sounds supported by device clients to override the user's default sound choice, see https://pushover.net/api#sounds])
# ARG_OPTIONAL_SINGLE([timestamp],[],[a Unix timestamp of your message's date and time to display to the user, rather than the time your message is received by our API])

# ARG_OPTIONAL_SINGLE([retry],[],[specifies how often (in seconds) the Pushover servers will send the same notification to the user. In a situation where your user might be in a noisy environment or sleeping, retrying the notification (with sound and vibration) will help get his or her attention. This parameter must have a value of at least 30 seconds between retries])
# ARG_OPTIONAL_SINGLE([expire],[],[specifies how many seconds your notification will continue to be retried for (every retry seconds). If the notification has not been acknowledged in expire seconds, it will be marked as expired and will stop being sent to the user. Note that the notification is still shown to the user after it is expired, but it will not prompt the user for acknowledgement. This parameter must have a maximum value of at most 10800 seconds (3 hours)])
# ARG_OPTIONAL_SINGLE([callback],[],[a publicly-accessible URL that our servers will send a request to when the user has acknowledged your notification])

# ARG_USE_PROG([CURL], [/usr/bin/curl], [pointing at the curl command, supports CURL_OPTS env variable], [--version])

# ARG_HELP([pushover shell client])
# ARG_VERSION([version])
# ARG_POSITIONAL_DOUBLEDASH([])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

# Setting environmental variables

# # When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die() {
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option() {
	local first_option all_short_options='tumhv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_token=
_arg_user=
_arg_message=
_arg_attachment=
_arg_device=
_arg_title=
_arg_url=
_arg_url_title=
_arg_priority=
_arg_sound=
_arg_timestamp=
_arg_retry=
_arg_expire=
_arg_callback=


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help() {
	printf '%s\n' "pushover shell client"
	printf 'Usage: %s [-t|--token <arg>] [-u|--user <arg>] [-m|--message <arg>] [--attachment <arg>] [--device <arg>] [--title <arg>] [--url <arg>] [--url_title <arg>] [--priority <arg>] [--sound <arg>] [--timestamp <arg>] [--retry <arg>] [--expire <arg>] [--callback <arg>] [-h|--help] [-v|--version]\n' "$0"
	printf '\t%s\n' "-t, --token: your application's API token (no default)"
	printf '\t%s\n' "-u, --user: the user/group key (not e-mail address) of your user (or you), viewable when logged into our dashboard (often referred to as USER_KEY in our documentation and code examples) (no default)"
	printf '\t%s\n' "-m, --message: your message (no default)"
	printf '\t%s\n' "--attachment: an image attachment to send with the message; see attachments for more information on how to upload files (no default)"
	printf '\t%s\n' "--device: your user's device name to send the message directly to that device, rather than all of the user's devices (multiple devices may be separated by a comma (no default)"
	printf '\t%s\n' "--title: your message's title, otherwise your app's name is used (no default)"
	printf '\t%s\n' "--url: a supplementary URL to show with your message (no default)"
	printf '\t%s\n' "--url_title: a title for your supplementary URL, otherwise just the URL is shown (no default)"
	printf '\t%s\n' "--priority: send as -2 to generate no notification/alert, -1 to always send as a quiet notification, 1 to display as high-priority and bypass the user's quiet hours, or 2 to also require confirmation from the user (no default)"
	printf '\t%s\n' "--sound: the name of one of the sounds supported by device clients to override the user's default sound choice, see https://pushover.net/api#sounds (no default)"
	printf '\t%s\n' "--timestamp: a Unix timestamp of your message's date and time to display to the user, rather than the time your message is received by our API (no default)"
	printf '\t%s\n' "--retry: specifies how often (in seconds) the Pushover servers will send the same notification to the user. In a situation where your user might be in a noisy environment or sleeping, retrying the notification (with sound and vibration) will help get his or her attention. This parameter must have a value of at least 30 seconds between retries (no default)"
	printf '\t%s\n' "--expire: specifies how many seconds your notification will continue to be retried for (every retry seconds). If the notification has not been acknowledged in expire seconds, it will be marked as expired and will stop being sent to the user. Note that the notification is still shown to the user after it is expired, but it will not prompt the user for acknowledgement. This parameter must have a maximum value of at most 10800 seconds (3 hours) (no default)"
	printf '\t%s\n' "--callback: a publicly-accessible URL that our servers will send a request to when the user has acknowledged your notification (no default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
	printf '\nEnvironment variables that are supported:\n'
	printf '\t%s\n' "PUSHOVER_TOKEN: used as fallback."
	printf '\t%s\n' "PUSHOVER_USER: used as fallback."

}

# The parsing of the command-line
parse_commandline() {
	while test $# -gt 0; do
		_key="$1"
		case "$_key" in
		# We support whitespace as a delimiter between option argument and its value.
		# Therefore, we expect the --token or -t value.
		# so we watch for --token and -t.
		# Since we know that we got the long or short option,
		# we just reach out for the next argument to get the value.
		-t | --token)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_token="$2"
			shift
			;;
		# We support the = as a delimiter between option argument and its value.
		# Therefore, we expect --token=value, so we watch for --token=*
		# For whatever we get, we strip '--token=' using the ${var##--token=} notation
		# to get the argument value
		--token=*)
			_arg_token="${_key##--token=}"
			;;
		# We support getopts-style short arguments grouping,
		# so as -t accepts value, we allow it to be appended to it, so we watch for -t*
		# and we strip the leading -t from the argument string using the ${var##-t} notation.
		-t*)
			_arg_token="${_key##-t}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		-u | --user)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_user="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--user=*)
			_arg_user="${_key##--user=}"
			;;
		# See the comment of option '-t' to see what's going on here - principle is the same.
		-u*)
			_arg_user="${_key##-u}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		-m | --message)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_message="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--message=*)
			_arg_message="${_key##--message=}"
			;;
		# See the comment of option '-t' to see what's going on here - principle is the same.
		-m*)
			_arg_message="${_key##-m}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--attachment)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_attachment="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--attachment=*)
			_arg_attachment="${_key##--attachment=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--device)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_device="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--device=*)
			_arg_device="${_key##--device=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--title)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_title="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--title=*)
			_arg_title="${_key##--title=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--url)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_url="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--url=*)
			_arg_url="${_key##--url=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--url_title)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_url_title="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--url_title=*)
			_arg_url_title="${_key##--url_title=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--priority)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_priority="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--priority=*)
			_arg_priority="${_key##--priority=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--sound)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_sound="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--sound=*)
			_arg_sound="${_key##--sound=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--timestamp)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_timestamp="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--timestamp=*)
			_arg_timestamp="${_key##--timestamp=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--retry)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_retry="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--retry=*)
			_arg_retry="${_key##--retry=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--expire)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_expire="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--expire=*)
			_arg_expire="${_key##--expire=}"
			;;
		# See the comment of option '--token' to see what's going on here - principle is the same.
		--callback)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_callback="$2"
			shift
			;;
		# See the comment of option '--token=' to see what's going on here - principle is the same.
		--callback=*)
			_arg_callback="${_key##--callback=}"
			;;
		# The help argurment doesn't accept a value,
		# we expect the --help or -h, so we watch for them.
		-h | --help)
			print_help
			exit 0
			;;
		# We support getopts-style short arguments clustering,
		# so as -h doesn't accept value, other short options may be appended to it, so we watch for -h*.
		# After stripping the leading -h from the argument, we have to make sure
		# that the first character that follows coresponds to a short option.
		-h*)
			print_help
			exit 0
			;;
		# See the comment of option '--help' to see what's going on here - principle is the same.
		-v | --version)
			version
			exit 0
			;;
		# See the comment of option '-h' to see what's going on here - principle is the same.
		-v*)
			version
			exit 0
			;;
		*)
			_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
			;;
		esac
		shift
	done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

set -o errexit
set -o pipefail
set -o nounset

__dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
__file="${__dir}/$(basename "${BASH_SOURCE[0]}")"
__base="$(basename "${__file}" .sh)"

VERSION="1.2.3-1"
PUSHOVER_URL="https://api.pushover.net/1/messages.json"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
logfile="${PUSHOVER_LOG:-${XDG_CACHE_HOME}/push.log}"

# support for SystemD execstop
# -> https://www.freedesktop.org/software/systemd/man/systemd.service.html#Command%20lines
# -> https://www.freedesktop.org/software/systemd/man/systemd.service.html#ExecStopPost=
# -> https://www.freedesktop.org/software/systemd/man/systemd.exec.html#%24EXIT_CODE
# $SERVICE_RESULT, $EXIT_CODE and $EXIT_STATUS

CURL="$(which curl)"

gnudate() {
	if command -v gdate >/dev/null 2>&1; then
		gdate "$@"
	else
		date "$@"
	fi
}

log() {
	# level=${1^^} # only works in bash v4+
	level="$(echo -n "${1}" | tr '[:lower:]' '[:upper:]')"
	shift
	echo "$(gnudate -Iseconds) [${__base}] ${level}: ${*}" | tee -a "${logfile}" # instead of "${@} as they would be expanded independently"
}

version() {
	echo "${__base} v${VERSION}"
}

opt_field() {
	field="${1}"
	shift
	value="${*}"
	if [ -n "${value}" ]; then
		echo -ne "--form \"${field}=${value}\""
	fi
}

### ENV fallback ###
token="${_arg_token:-$PUSHOVER_TOKEN}"
user="${_arg_user:-$PUSHOVER_USER}"
####################

if [ -z "${token}" ] || [ -z "${user}" ]; then
	log "error" "both --user and --token arguments are required"
	die "Exiting..." 1
fi

if [ -z "${_arg_message}" ]; then
	log "error" "--message argument is required."
	die "Exiting..." 1
fi

if [ -n "${_arg_timestamp}" ]; then
	time="$(gnudate "+%s" -d "${_arg_timestamp}")"
fi

curl_args=(
	--request POST
	--silent
	--show-error
	"${CURL_OPTS:-}"
	--form "token=${token}"
	--form "user=${user}"
	--form "\"message="${_arg_message}\"
	"${_arg_title:+--form \"title="${_arg_title}"\"}"
	"${_arg_url:+--form \"url="${_arg_url}"\"}"
	"${_arg_url_title:+--form \"url="${_arg_url_title}"\"}"
	"${_arg_device:+--form \"device="${_arg_device}"\"}"
	"${_arg_sound:+--form \"sound="${_arg_sound}"\"}"
	"${_arg_html:+--form \"html="${_arg_html}"\"}"
	"${_arg_monospace:+--form \"monospace="${_arg_monospace}"\"}"
	"${_arg_attachment:+--form \"attachment="${_arg_attachment}"\"}"
	"${time:+--form \"timestamp="${time}"\"}"
	"${_arg_priority:+--form \"priority="${_arg_priority}"\"}"
	"${_arg_retry:+--form \"retry="${_arg_retry}"\"}"
	"${_arg_expire:+--form \"expire="${_arg_expire}"\"}"
	"${_arg_callback:+--form \"callback="${_arg_callback}"\"}"
)

log "info" "${curl_args[@]}"

log "info" "sending notification..."
eval "${CURL}" "${curl_args[@]}" "${PUSHOVER_URL}"
curl_exit="$?"

if [ ! "${curl_exit}" == "0" ]; then
	log "error" "curl failed with exit code: ${curl_exit}"
	die "Exiting..." 1
fi

echo

# die "Success..." "${curl_exit}"

# ] <-- needed because of Argbash
